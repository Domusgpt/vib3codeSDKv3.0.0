/**
 * Collectible Card Batch Generator — Generated by /vib3-create skill
 *
 * Generates unique collectible trading cards using the VIB3+ evolutionary
 * art pipeline: randomize → describe → capture → export → persist.
 *
 * Usage:
 *   import { CardGenerator } from './collectible-card-generator.js';
 *
 *   // With live MCP server
 *   const gen = new CardGenerator(mcpClient);
 *   const cards = await gen.generateBatch(10);
 *
 *   // Without MCP (standalone generation)
 *   const presets = CardGenerator.generatePresetBatch(10);
 *   const presets = CardGenerator.generateThemedBatch('deepSpace', 5);
 *   const evolved = CardGenerator.evolveCollection(seedPreset, 3, 5);
 */

// ── Preset Generation (No MCP needed) ───────────────────────────────

const PARAM_RANGES = {
    geometry:    { min: 0,   max: 23,  step: 1, type: 'int' },
    rot4dXY:     { min: 0,   max: 6.2831853, type: 'float' },
    rot4dXZ:     { min: 0,   max: 6.2831853, type: 'float' },
    rot4dYZ:     { min: 0,   max: 6.2831853, type: 'float' },
    rot4dXW:     { min: 0,   max: 6.2831853, type: 'float' },
    rot4dYW:     { min: 0,   max: 6.2831853, type: 'float' },
    rot4dZW:     { min: 0,   max: 6.2831853, type: 'float' },
    gridDensity: { min: 4,   max: 100, type: 'float' },
    morphFactor: { min: 0,   max: 2,   type: 'float' },
    chaos:       { min: 0,   max: 1,   type: 'float' },
    speed:       { min: 0.1, max: 3,   type: 'float' },
    hue:         { min: 0,   max: 360, type: 'float' },
    intensity:   { min: 0,   max: 1,   type: 'float' },
    saturation:  { min: 0,   max: 1,   type: 'float' },
    dimension:   { min: 3.0, max: 4.5, type: 'float' }
};

const GEOMETRY_NAMES = [
    'TETRAHEDRON', 'HYPERCUBE', 'SPHERE', 'TORUS',
    'KLEIN BOTTLE', 'FRACTAL', 'WAVE', 'CRYSTAL'
];

const CORE_TYPES = ['BASE', 'HYPERSPHERE', 'HYPERTETRA'];

const SYSTEMS = ['quantum', 'faceted', 'holographic'];

const THEMES = {
    deepSpace:   { hue: [220, 280], chaos: [0.1, 0.3], speed: [0.2, 0.5], intensity: [0.2, 0.5], saturation: [0.5, 0.8], dimension: [3.0, 3.3] },
    lavaLamp:    { hue: [0, 30],    chaos: [0.3, 0.6], speed: [0.3, 0.8], intensity: [0.6, 0.9], saturation: [0.8, 1.0], dimension: [3.3, 3.8] },
    arctic:      { hue: [180, 210], chaos: [0.0, 0.1], speed: [0.1, 0.3], intensity: [0.7, 0.9], saturation: [0.3, 0.6], dimension: [3.5, 4.2] },
    acid:        { hue: [80, 160],  chaos: [0.5, 1.0], speed: [1.5, 3.0], intensity: [0.7, 1.0], saturation: [0.9, 1.0], dimension: [3.0, 3.2] },
    meditation:  { hue: [260, 320], chaos: [0.0, 0.05],speed: [0.1, 0.3], intensity: [0.3, 0.5], saturation: [0.3, 0.5], dimension: [3.8, 4.5] },
    storm:       { hue: [200, 240], chaos: [0.6, 1.0], speed: [1.0, 2.5], intensity: [0.3, 0.7], saturation: [0.4, 0.7], dimension: [3.0, 3.4] },
    synthwave:   { hue: [280, 340], chaos: [0.1, 0.3], speed: [0.5, 1.0], intensity: [0.6, 0.9], saturation: [0.7, 1.0], dimension: [3.3, 3.8] },
    nature:      { hue: [80, 160],  chaos: [0.1, 0.3], speed: [0.3, 0.8], intensity: [0.4, 0.7], saturation: [0.5, 0.8], dimension: [3.5, 4.0] }
};

function randomInRange(min, max) {
    return min + Math.random() * (max - min);
}

function randomInt(min, max) {
    return Math.floor(min + Math.random() * (max - min + 1));
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/** Gaussian-like perturbation using Box-Muller */
function gaussianRandom(mean = 0, stddev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    return mean + stddev * Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
}

/** Calculate rarity from extremity (same formula as TradingCardGenerator) */
function calculateRarity(preset) {
    const extremity =
        Math.abs(preset.rot4dXW) +
        Math.abs(preset.rot4dYW) +
        Math.abs(preset.rot4dZW) +
        (preset.chaos * 2) +
        Math.abs(preset.dimension - 3.8);
    if (extremity > 8) return 'MYTHIC';
    if (extremity > 6) return 'LEGENDARY';
    if (extremity > 4) return 'EPIC';
    if (extremity > 2) return 'RARE';
    return 'COMMON';
}

/** Generate a fully random preset */
function generateRandomPreset(theme = null) {
    const themeRanges = theme && THEMES[theme] ? THEMES[theme] : null;

    const preset = {
        name: '',
        description: '',
        system: SYSTEMS[randomInt(0, 2)],
        timestamp: Date.now()
    };

    for (const [param, range] of Object.entries(PARAM_RANGES)) {
        if (themeRanges && themeRanges[param]) {
            const [tMin, tMax] = themeRanges[param];
            preset[param] = range.type === 'int'
                ? randomInt(tMin, tMax)
                : randomInRange(tMin, tMax);
        } else {
            preset[param] = range.type === 'int'
                ? randomInt(range.min, range.max)
                : randomInRange(range.min, range.max);
        }
    }

    // Derive name from geometry
    const baseGeo = preset.geometry % 8;
    const coreType = Math.floor(preset.geometry / 8);
    preset.name = `${GEOMETRY_NAMES[baseGeo]} ${CORE_TYPES[coreType]}`;
    preset.rarity = calculateRarity(preset);
    preset.description = describePreset(preset);

    return preset;
}

/** Generate natural language description from parameters */
function describePreset(preset) {
    const parts = [];

    // Energy level
    if (preset.speed > 2.0) parts.push('high-energy');
    else if (preset.speed > 1.0) parts.push('dynamic');
    else if (preset.speed > 0.4) parts.push('gentle');
    else parts.push('near-frozen');

    // Color family
    const h = preset.hue;
    if (h < 30 || h > 340) parts.push('red');
    else if (h < 70) parts.push('golden');
    else if (h < 150) parts.push('green');
    else if (h < 210) parts.push('ocean-blue');
    else if (h < 280) parts.push('violet');
    else parts.push('magenta');

    // Chaos level
    if (preset.chaos > 0.7) parts.push('chaotic');
    else if (preset.chaos > 0.3) parts.push('turbulent');
    else if (preset.chaos > 0.05) parts.push('textured');
    else parts.push('pristine');

    // Complexity
    if (preset.gridDensity > 60) parts.push('intricate');
    else if (preset.gridDensity > 30) parts.push('detailed');
    else if (preset.gridDensity > 15) parts.push('balanced');
    else parts.push('minimal');

    // 4D depth
    const rot4dTotal = Math.abs(preset.rot4dXW) + Math.abs(preset.rot4dYW) + Math.abs(preset.rot4dZW);
    if (rot4dTotal > 8) parts.push('deep hyperspace');
    else if (rot4dTotal > 3) parts.push('4D warped');
    else if (rot4dTotal > 0.5) parts.push('subtly dimensional');

    return parts.join(', ');
}

/** Mutate a preset (Gaussian perturbation) */
function mutate(preset, intensity = 0.3) {
    const mutated = { ...preset, timestamp: Date.now() };

    for (const [param, range] of Object.entries(PARAM_RANGES)) {
        if (param === 'geometry' && Math.random() > 0.7) {
            // 30% chance to change geometry entirely
            mutated.geometry = randomInt(range.min, range.max);
        } else {
            const span = range.max - range.min;
            const perturbation = gaussianRandom(0, span * intensity * 0.3);
            let newValue = preset[param] + perturbation;
            newValue = clamp(newValue, range.min, range.max);
            mutated[param] = range.type === 'int' ? Math.round(newValue) : newValue;
        }
    }

    const baseGeo = mutated.geometry % 8;
    const coreType = Math.floor(mutated.geometry / 8);
    mutated.name = `${GEOMETRY_NAMES[baseGeo]} ${CORE_TYPES[coreType]}`;
    mutated.rarity = calculateRarity(mutated);
    mutated.description = describePreset(mutated);
    return mutated;
}

/** Crossbreed two presets */
function crossbreed(presetA, presetB, ratio = 0.5) {
    const child = { timestamp: Date.now() };

    for (const [param, range] of Object.entries(PARAM_RANGES)) {
        if (range.type === 'int') {
            child[param] = Math.random() < ratio ? presetB[param] : presetA[param];
        } else {
            child[param] = presetA[param] * (1 - ratio) + presetB[param] * ratio;
        }
    }

    child.system = Math.random() < ratio ? presetB.system : presetA.system;
    const baseGeo = child.geometry % 8;
    const coreType = Math.floor(child.geometry / 8);
    child.name = `${GEOMETRY_NAMES[baseGeo]} ${CORE_TYPES[coreType]}`;
    child.rarity = calculateRarity(child);
    child.description = describePreset(child);
    return child;
}

// ── Public API ───────────────────────────────────────────────────────

export class CardGenerator {

    constructor(mcpClient = null) {
        this.mcpClient = mcpClient;
        this.collection = [];
    }

    /**
     * Generate N unique cards via MCP (live mode).
     * Requires MCP client with randomize_parameters, describe_visual_state,
     * capture_screenshot, and save_to_gallery tools.
     */
    async generateBatch(count = 10) {
        if (!this.mcpClient) {
            throw new Error('MCP client required for live card generation. Use static methods for offline.');
        }

        const cards = [];
        for (let i = 0; i < count; i++) {
            // Step 1: Randomize
            await this.mcpClient.callTool('randomize_parameters', {});

            // Step 2: Describe
            const description = await this.mcpClient.callTool('describe_visual_state', {});

            // Step 3: Capture
            const screenshot = await this.mcpClient.callTool('capture_screenshot', {
                width: 512, height: 512, layers: 'composite'
            });

            // Step 4: Get state for metadata
            const state = await this.mcpClient.callTool('get_state', {});

            // Step 5: Save to gallery
            const slot = 30 + (i % 70);  // slots 30-99
            await this.mcpClient.callTool('save_to_gallery', { slot, name: `Card #${i + 1}` });

            cards.push({
                index: i,
                description: description?.description ?? 'Unknown',
                screenshot: screenshot?.image ?? null,
                state: state,
                gallerySlot: slot,
                rarity: calculateRarity(state ?? {}),
                timestamp: Date.now()
            });
        }

        this.collection.push(...cards);
        return cards;
    }

    /**
     * Generate N random preset cards (offline, no MCP needed).
     */
    static generatePresetBatch(count = 10) {
        return Array.from({ length: count }, () => generateRandomPreset());
    }

    /**
     * Generate N themed preset cards.
     * @param {string} theme - One of: deepSpace, lavaLamp, arctic, acid, meditation, storm, synthwave, nature
     */
    static generateThemedBatch(theme, count = 5) {
        return Array.from({ length: count }, () => generateRandomPreset(theme));
    }

    /**
     * Evolutionary art: mutate a seed preset over N generations,
     * keeping the best K per generation (by rarity score).
     *
     * @param {Object} seed - Starting preset
     * @param {number} generations - Number of evolution rounds
     * @param {number} populationSize - Mutations per generation
     * @returns {Object[]} Final generation sorted by rarity
     */
    static evolveCollection(seed, generations = 3, populationSize = 5) {
        const RARITY_SCORES = { COMMON: 1, RARE: 2, EPIC: 3, LEGENDARY: 4, MYTHIC: 5 };
        let population = [seed];

        for (let gen = 0; gen < generations; gen++) {
            const newPop = [];

            // Mutate each member
            for (const member of population) {
                for (let i = 0; i < populationSize; i++) {
                    const intensity = 0.1 + (gen * 0.1);  // increase mutation over generations
                    newPop.push(mutate(member, intensity));
                }
            }

            // Crossbreed top 2
            newPop.sort((a, b) => (RARITY_SCORES[b.rarity] ?? 0) - (RARITY_SCORES[a.rarity] ?? 0));
            if (newPop.length >= 2) {
                newPop.push(crossbreed(newPop[0], newPop[1], 0.5));
                newPop.push(crossbreed(newPop[0], newPop[1], 0.3));
                newPop.push(crossbreed(newPop[0], newPop[1], 0.7));
            }

            // Select top performers
            newPop.sort((a, b) => (RARITY_SCORES[b.rarity] ?? 0) - (RARITY_SCORES[a.rarity] ?? 0));
            population = newPop.slice(0, Math.max(3, populationSize));
        }

        return population;
    }
}

// ── Demo: Generate and display ───────────────────────────────────────

/**
 * Quick demo that generates cards and prints them.
 * Run: node collectible-card-generator.js
 */
if (typeof process !== 'undefined' && process.argv[1]?.endsWith('collectible-card-generator.js')) {
    console.log('=== VIB3+ Collectible Card Generator Demo ===\n');

    // Random batch
    console.log('--- 5 Random Cards ---');
    const randomCards = CardGenerator.generatePresetBatch(5);
    for (const card of randomCards) {
        console.log(`  [${card.rarity.padEnd(9)}] ${card.name.padEnd(24)} | ${card.description}`);
    }

    // Themed batch
    console.log('\n--- 5 Deep Space Cards ---');
    const spaceCards = CardGenerator.generateThemedBatch('deepSpace', 5);
    for (const card of spaceCards) {
        console.log(`  [${card.rarity.padEnd(9)}] ${card.name.padEnd(24)} | ${card.description}`);
    }

    // Evolutionary art
    console.log('\n--- Evolved Collection (3 generations from synthwave seed) ---');
    const seed = generateRandomPreset('synthwave');
    console.log(`  Seed: [${seed.rarity.padEnd(9)}] ${seed.name.padEnd(24)} | ${seed.description}`);
    const evolved = CardGenerator.evolveCollection(seed, 3, 5);
    console.log('  Evolved:');
    for (const card of evolved) {
        console.log(`    [${card.rarity.padEnd(9)}] ${card.name.padEnd(24)} | ${card.description}`);
    }

    // Rarity distribution
    console.log('\n--- Rarity Distribution (100 random cards) ---');
    const bigBatch = CardGenerator.generatePresetBatch(100);
    const dist = {};
    for (const card of bigBatch) {
        dist[card.rarity] = (dist[card.rarity] || 0) + 1;
    }
    for (const [rarity, count] of Object.entries(dist).sort((a, b) => b[1] - a[1])) {
        const bar = '#'.repeat(count);
        console.log(`  ${rarity.padEnd(9)} ${String(count).padStart(3)}  ${bar}`);
    }
}

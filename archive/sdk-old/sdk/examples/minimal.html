<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>VIB3+ Minimal - Working 4D Visualization</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font: 14px monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="info">VIB3+ 4D Geometry - Move mouse to rotate</div>

    <script>
        // MINIMAL VIB3+ IMPLEMENTATION
        // This is a complete working 4D visualization in ~100 lines

        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        // Auto-resize
        function resize() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.onresize = resize;

        // Mouse tracking for rotation
        let mouseX = 0.5, mouseY = 0.5;
        document.onmousemove = e => {
            mouseX = e.clientX / window.innerWidth;
            mouseY = e.clientY / window.innerHeight;
        };

        // Shaders
        const vs = `attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}`;
        const fs = `
precision highp float;
uniform vec2 r;
uniform float t;
uniform vec2 m;

mat4 rXW(float a){float c=cos(a),s=sin(a);return mat4(c,0,0,-s,0,1,0,0,0,0,1,0,s,0,0,c);}
mat4 rYW(float a){float c=cos(a),s=sin(a);return mat4(1,0,0,0,0,c,0,-s,0,0,1,0,0,s,0,c);}
mat4 rZW(float a){float c=cos(a),s=sin(a);return mat4(1,0,0,0,0,1,0,0,0,0,c,-s,0,0,s,c);}

float hypercube(vec3 p){
    vec3 g=fract(p*3.0);
    vec3 e=min(g,1.0-g);
    return 1.0-smoothstep(0.0,0.05,min(min(e.x,e.y),e.z));
}

void main(){
    vec2 uv=(gl_FragCoord.xy-r*.5)/min(r.x,r.y);

    // Create 4D point
    vec4 p=vec4(uv*2.0,sin(t*0.5),cos(t*0.3));

    // Apply 4D rotations based on mouse
    float rotXW=(m.x-0.5)*6.28;
    float rotYW=(m.y-0.5)*6.28;
    float rotZW=t*0.2;

    p=rXW(rotXW)*p;
    p=rYW(rotYW)*p;
    p=rZW(rotZW)*p;

    // Project 4D to 3D
    float w=2.0/(2.0+p.w);
    vec3 p3=p.xyz*w;

    // Get geometry
    float v=hypercube(p3);

    // Color from position
    float hue=atan(uv.y,uv.x)/6.28+t*0.05;
    vec3 col=.5+.5*cos(6.28*(hue+vec3(0,.33,.67)));
    col*=v;
    col+=vec3(0,.3,.5)*v*0.3;

    gl_FragColor=vec4(col,1);
}`;

        // Compile shader
        function compile(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }

        const prog = gl.createProgram();
        gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
        gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(prog);

        // Buffer
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

        const pos = gl.getAttribLocation(prog, 'p');
        gl.enableVertexAttribArray(pos);
        gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const uR = gl.getUniformLocation(prog, 'r');
        const uT = gl.getUniformLocation(prog, 't');
        const uM = gl.getUniformLocation(prog, 'm');

        // Render
        const start = Date.now();
        function render() {
            gl.useProgram(prog);
            gl.uniform2f(uR, canvas.width, canvas.height);
            gl.uniform1f(uT, (Date.now() - start) * 0.001);
            gl.uniform2f(uM, mouseX, mouseY);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>

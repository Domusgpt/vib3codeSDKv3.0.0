<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRYSTALLINE VOID MEDITATION [4/13]</title>
    <meta name="description" content="Explores the negative space between polytope vertices as a metaphor for existential absence">
    <meta name="generator" content="VIB3+ Algorithmic Avant-Garde Generator v2.718">
    <meta name="pcs" content="1.51235025">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .metadata-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 20px;
            color: #0f0;
            font-size: 10px;
            max-width: 400px;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
        }
        .metadata-panel h1 {
            color: #0ff;
            font-size: 12px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .metadata-panel .description {
            color: #888;
            font-style: italic;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        .metadata-panel .param-group {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0,255,0,0.05);
            border-left: 2px solid #0f0;
        }
        .metadata-panel .param-group h2 {
            color: #0ff;
            font-size: 10px;
            margin-bottom: 5px;
        }
        .metadata-panel .param {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        .metadata-panel .param-name { color: #888; }
        .metadata-panel .param-value { color: #0f0; font-family: monospace; }
        .metadata-panel .pcs {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }
        .metadata-panel .pcs-label { color: #888; font-size: 9px; }
        .metadata-panel .pcs-value { color: #ff0; font-size: 16px; font-weight: bold; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="metadata-panel">
        <h1>crystalline void meditation</h1>
        <div class="description">Explores the negative space between polytope vertices as a metaphor for existential absence</div>

        <div class="param-group">
            <h2>6D ROTATION MANIFOLD</h2>
            <div class="param"><span class="param-name">XY:</span><span class="param-value">1.296415769720 rad</span></div>
            <div class="param"><span class="param-name">XZ:</span><span class="param-value">1.306164799417 rad</span></div>
            <div class="param"><span class="param-name">YZ:</span><span class="param-value">0.000000000000 rad</span></div>
            <div class="param"><span class="param-name">XW:</span><span class="param-value">3.666817528025 rad</span></div>
            <div class="param"><span class="param-name">YW:</span><span class="param-value">6.149439940315 rad</span></div>
            <div class="param"><span class="param-name">ZW:</span><span class="param-value">1.617004214587 rad</span></div>
        </div>

        <div class="param-group">
            <h2>CHROMATIC</h2>
            <div class="param"><span class="param-name">Hue:</span><span class="param-value">215.27864045Â°</span></div>
            <div class="param"><span class="param-name">Saturation:</span><span class="param-value">0.896800375646</span></div>
            <div class="param"><span class="param-name">Intensity:</span><span class="param-value">0.437046398657</span></div>
        </div>

        <div class="param-group">
            <h2>DYNAMICS</h2>
            <div class="param"><span class="param-name">Speed:</span><span class="param-value">0.535845964688</span></div>
            <div class="param"><span class="param-name">Chaos:</span><span class="param-value">0.239308074468</span></div>
            <div class="param"><span class="param-name">Morph:</span><span class="param-value">0.693752311645</span></div>
        </div>

        <div class="pcs">
            <div class="pcs-label">PERCEPTUAL COMPLEXITY SCORE</div>
            <div class="pcs-value">1.51235025</div>
        </div>
    </div>

    <script>
        // Mathematical constants
        const PHI = 1.618033988749895;
        const TAU = 6.283185307179586;

        // Baked parameters from algorithmic generation
        const PARAMS = {
        "XY": 1.2964157697202587,
        "XZ": 1.3061647994168855,
        "YZ": 0,
        "XW": 3.6668175280254918,
        "YW": 6.149439940314558,
        "ZW": 1.6170042145873067,
        "hue": 215.27864045000422,
        "saturation": 0.896800375645848,
        "intensity": 0.437046398657398,
        "geometry": 15,
        "speed": 0.5358459646883426,
        "chaos": 0.23930807446824554,
        "morphFactor": 0.6937523116448714,
        "gridDensity": 10
};

        // WebGL initialization
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        function resize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Vertex shader
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        // Fragment shader with quantum system characteristics
        const fsSource = `
            precision highp float;

            uniform float u_time;
            uniform vec2 u_resolution;

            // Baked parameters
            const float ROT_XY = 1.296415769720259;
            const float ROT_XZ = 1.306164799416885;
            const float ROT_YZ = 0.000000000000000;
            const float ROT_XW = 3.666817528025492;
            const float ROT_YW = 6.149439940314558;
            const float ROT_ZW = 1.617004214587307;
            const float HUE = 215.278640450004218;
            const float SAT = 0.896800375645848;
            const float INTENSITY = 0.437046398657398;
            const float SPEED = 0.535845964688343;
            const float CHAOS = 0.239308074468246;
            const float MORPH = 0.693752311644871;
            const float GRID = 10.0;
            const int GEOMETRY = 15;

            // 4D rotation matrices
            mat4 rotateXY(float a) {
                float c = cos(a), s = sin(a);
                return mat4(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1);
            }
            mat4 rotateXZ(float a) {
                float c = cos(a), s = sin(a);
                return mat4(c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1);
            }
            mat4 rotateYZ(float a) {
                float c = cos(a), s = sin(a);
                return mat4(1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1);
            }
            mat4 rotateXW(float a) {
                float c = cos(a), s = sin(a);
                return mat4(c,0,0,-s, 0,1,0,0, 0,0,1,0, s,0,0,c);
            }
            mat4 rotateYW(float a) {
                float c = cos(a), s = sin(a);
                return mat4(1,0,0,0, 0,c,0,-s, 0,0,1,0, 0,s,0,c);
            }
            mat4 rotateZW(float a) {
                float c = cos(a), s = sin(a);
                return mat4(1,0,0,0, 0,1,0,0, 0,0,c,-s, 0,0,s,c);
            }

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float sdf4D(vec4 p) {
                // Geometry selection based on index
                int baseGeom = GEOMETRY - (GEOMETRY / 8) * 8;
                int coreType = GEOMETRY / 8;

                float d = length(p) - 1.0;

                // Base geometry modifications
                if (baseGeom == 0) { // Tetrahedron
                    d = max(d, dot(p.xyz, normalize(vec3(1,1,1))) - 0.5);
                } else if (baseGeom == 1) { // Hypercube
                    vec4 q = abs(p) - vec4(0.5);
                    d = length(max(q, 0.0)) + min(max(q.x, max(q.y, max(q.z, q.w))), 0.0);
                } else if (baseGeom == 3) { // Torus
                    vec2 q = vec2(length(p.xz) - 0.5, p.y);
                    d = length(q) - 0.2;
                } else if (baseGeom == 4) { // Klein-ish
                    d = sin(p.x * 3.0) * sin(p.y * 3.0) * sin(p.z * 3.0) * 0.3 + length(p) - 1.0;
                } else if (baseGeom == 5) { // Fractal
                    vec3 z = p.xyz;
                    float dr = 1.0;
                    float r = 0.0;
                    for (int i = 0; i < 4; i++) {
                        r = length(z);
                        if (r > 2.0) break;
                        float theta = acos(z.z / r);
                        float phi = atan(z.y, z.x);
                        dr = pow(r, 7.0) * 8.0 * dr + 1.0;
                        float zr = pow(r, 8.0);
                        theta *= 8.0;
                        phi *= 8.0;
                        z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p.xyz;
                    }
                    d = 0.5 * log(r) * r / dr;
                }

                // Core type warp
                if (coreType == 1) { // Hypersphere
                    d = mix(d, length(p) - 1.0, 0.5);
                } else if (coreType == 2) { // Hypertetrahedron
                    d += sin(p.w * 5.0) * 0.1;
                }

                return d;
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
                float t = u_time * SPEED;

                // Animated rotation
                float aXY = ROT_XY + t * 0.1;
                float aXZ = ROT_XZ + t * 0.07;
                float aYZ = ROT_YZ + t * 0.05;
                float aXW = ROT_XW + t * 0.13 * CHAOS;
                float aYW = ROT_YW + t * 0.11 * CHAOS;
                float aZW = ROT_ZW + t * 0.09 * CHAOS;

                mat4 rot = rotateXY(aXY) * rotateXZ(aXZ) * rotateYZ(aYZ) *
                           rotateXW(aXW) * rotateYW(aYW) * rotateZW(aZW);

                // Ray marching
                vec3 ro = vec3(0, 0, -3);
                vec3 rd = normalize(vec3(uv, 1.0));

                float totalDist = 0.0;
                vec3 col = vec3(0);

                for (int i = 0; i < 64; i++) {
                    vec3 p3 = ro + rd * totalDist;
                    vec4 p4 = rot * vec4(p3, sin(t * 0.5) * MORPH);

                    float d = sdf4D(p4);

                    if (d < 0.001) {
                        float hue = HUE / 360.0 + totalDist * 0.1;
                        col = hsv2rgb(vec3(hue, SAT, INTENSITY));
                        col *= 1.0 - totalDist * 0.1;
                        break;
                    }

                    if (totalDist > 10.0) break;
                    totalDist += d * 0.5;
                }

                // Grid overlay
                vec2 grid = fract(uv * GRID);
                float gridLine = smoothstep(0.02, 0.0, min(grid.x, grid.y)) * 0.1;
                col += vec3(gridLine);

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Compile shaders
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Fullscreen quad
        const positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
        gl.enableVertexAttribArray(aVertexPosition);
        gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(program, 'u_time');
        const uResolution = gl.getUniformLocation(program, 'u_resolution');

        // Animation loop
        function render(time) {
            gl.uniform1f(uTime, time * 0.001);
            gl.uniform2f(uResolution, canvas.width, canvas.height);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        render(0);
    </script>
</body>
</html>